<PmmlSed>
    <PythonFunction name="action" deepestNode="Segment">
	<Context library="augustus.core.xmlbase" as="xmlbase" />
	<Context library="augustus.core.pmml41" as="pmml" />
	<Context library="random" />
	<![CDATA[

# if something (Segment or Node) doesn't have an id, give it a random one and hope for no collisions
# FIXME: Segments generated by Augustus are assigned truly unique ids--- why aren't they propagated to the output file???
def getUniqueId(obj):
    if "id" in obj.attrib:
        return obj.attrib["id"]
    else:
        return "%s-%d" % (obj.tag, random.randint(100000, 999999))

# recursively search through the TreeModel and accumulate a list of (name, predicateTuple) pairs
def searchNodes(node, predicateTuple, namePredicatePairs):
    # there are five types of predicates in PMML: <SimplePredicate/>, <CompoundPredicate/>, <SimpleSetPredicate/>, <True/>, <False/>
    predicate = node.child(lambda x: isinstance(x, (pmml.SimplePredicate, pmml.CompoundPredicate,
                                                    pmml.SimpleSetPredicate, pmml.pmmlTrue, pmml.pmmlFalse)))

    newPredicateTuple = predicateTuple + (predicate,)

    subNodes = node.matches(pmml.Node)
    if len(subNodes) == 0:
        namePredicatePairs.append((getUniqueId(node), newPredicateTuple))

    for subNode in subNodes:
        searchNodes(subNode, newPredicateTuple, namePredicatePairs)

# given a name and a tuple of predicates, make a new Segment with <REPLACEME/> as the model
def constructSegment(name, predicateTuple):
    # drop <True/> because it's useless and will slow down segment-finding (comes from the top of each tree)
    predicateTuple = filter(lambda x: not isinstance(x, pmml.pmmlTrue), predicateTuple)

    # completely ignore any predicateTuple containing <False/>
    if pmml.pmmlFalse() in predicateTuple:
        return None

    # if there's only one predicate (0-depth tree), put that one directly in the Segment
    if len(predicateTuple) == 1:
        return pmml.Segment(predicateTuple[0], xmlbase.XML("REPLACEME"), id=name)

    # otherwise combine the predicates into a new <CompoundPredicate booleanOperator="and"/>
    elif len(predicateTuple) >= 2:
        compoundPredicate = pmml.CompoundPredicate(*predicateTuple, **{"booleanOperator": "and"})
        return pmml.Segment(compoundPredicate, xmlbase.XML("REPLACEME"), id=name)

# applied to every XML node in the PMML file, down to deepestNode="Segment"
def action(pmmlSnippet):
    # if pmmlSnippet is a Segment, do the following
    if isinstance(pmmlSnippet, pmml.Segment):
        segment = pmmlSnippet
        segmentName = getUniqueId(segment)

        # the only non-Extension XML elements that valid Segments can contain are a predicate and a model, in that order
        segmentPredicate, model = segment.matches(pmml.nonExtension)
	
        # if it's not a TreeModel, do not change the Segment
	if not isinstance(model, pmml.TreeModel):
            return None

        namePredicatePairs = []
        searchNodes(model.child(pmml.Node), (segmentPredicate,), namePredicatePairs)

        newSegments = []
	for nodeName, predicateTuple in namePredicatePairs:
            newSegment = constructSegment("%s-%s" % (segmentName, nodeName), predicateTuple)
	    if newSegment is not None:
	        newSegments.append(newSegment)

        return newSegments

    # if pmmlSnippet is a TreeModel, then this must be an unsegmented file because deepestNode is "Segment"
    elif isinstance(pmmlSnippet, pmml.TreeModel):
        model = pmmlSnippet

        namePredicatePairs = []
        searchNodes(model.child(pmml.Node), (), namePredicatePairs)

        newSegments = []
	for nodeName, predicateTuple in namePredicatePairs:
            newSegment = constructSegment(nodeName, predicateTuple)
	    if newSegment is not None:
	        newSegments.append(newSegment)

        # make a new MiningModel and move all of the structure from the TreeModel into it
        miningModel = pmml.MiningModel(functionName="regression")
        miningModel.children.append(model.child(pmml.MiningSchema))
        miningModel.children.append(model.child(pmml.Output, exception=False))
        miningModel.children.append(model.child(pmml.ModelStats, exception=False))
        miningModel.children.append(model.child(pmml.ModelExplanation, exception=False))
        miningModel.children.append(model.child(pmml.Targets, exception=False))
        miningModel.children.append(model.child(pmml.LocalTransformations, exception=False))

        # the one thing that's different: instead of <Node>...</Node>, we have <Segmentation>...</Segmentation>
        miningModel.children.append(pmml.Segmentation(*newSegments, **{"multipleModelMethod": "selectFirst"}))

        miningModel.children.append(model.child(pmml.ModelVerification, exception=False))

        # some of the model.child calls might have returned None; we can't put None in an XML file
        miningModel.children = filter(lambda x: x is not None, miningModel.children)
        return miningModel
    ]]></PythonFunction>

    <FileInput fileName="biggertree.pmml" validate="true"/>
    <FileOutput fileName="intosegments.pmml" validate="false"/> 
</PmmlSed>
